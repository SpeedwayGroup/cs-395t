# Assignment 1a: Microarchitectural Simulators
**Due January 27th, 2024 at 11:59pm CST**

In this assignment, you will configure, build, and run two
microarchitectural simulators modeling a modern processor and compare
the statistics produced by each. Then you'll perform a short
experimental study of the impact of changing simulator configurations.
This assignment does not require you to write a lot of code, but it does
require developing comfort with how each simulator is configured and run
and learning some of the differences between them. Furthermore, it sets
you up for the Assignments 1b and 1c, where you'll change
each simulator to implement a predictor we've discussed in class.

# Assignment

The first part of your assignment is to download and build two
simulators (i.e., software programs that simulate the behavior of
hardware) used for microarchitectural research.

-   `gem5`: gem5 is a system-level simulator for computer systems and
    architecture research, supporting multiple instruction set
    architectures and providing detailed models of CPUs, GPUs, and
    various system-level components that can be instantiated and
    connected according to user specification. It can simulate the
    interactions of the entire system (full system, FS) or just a CPU
    running user-space code (syscall emulation, SE). It is an
    \"execute-in-execute\" simulator, meaning it actually executes
    instructions in the execute stage of the CPU (and will therefore
    execute and flush wrong-path instructions after a mispredicted
    branch).

-   `ChampSim`: ChampSim is a trace-based simulator intended for the
    study of CPU microarchitecture, and particularly prediction
    mechanisms. It executes traces of user-space code generated by Intel
    Pin, meaning that it knows only about committed instructions and
    cannot model wrong-path execution. It simplifies the CPU core model
    to have all instructions take a fixed latency except for the latency
    imposed by interaction with the memory system (the cache and memory
    models) and mispredicted branches.

You'll configure each simulator according to the instructions below, and
then simulate a given benchmark on both. They will not produce identical
results; we'd like you to think about why and discuss this in your
report. In the second part of the assignment, you'll run an experiment
on each simulator, describe what you did and report results, and draw
conclusions. You'll also describe other experiments you might run with
more time and/or simulator knowledge.

# Part 1: Getting Started

## Initial setup

To begin, please log in to one of the pedagogical machines (numbered 1
through 4) with your CS ID.

```shell
ssh pedagogical-1.cs.utexas.edu
```

For this class, we allocated some scratch space on the UT machines for you at
at `/projects/coursework/2025-spring/cs395t-lin/`. This directory should be
accessible on all the pedagogical machines as well as most other UTCS machines.

First, make a directory inside this folder with your UTCS ID.

```shell
mkdir /projects/coursework/2025-spring/cs395t-lin/$(whoami)
cd /projects/coursework/2025-spring/cs395t-lin/$(whoami)
```

> [!NOTE]
> If you can't access this folder, please reach out to the TAs.

> [!WARNING]
> This scratch space is NOT backed up, so, please keep copies of any files you 
> actually change or want to turn in somewhere else, too!

## gem5

Inside your personal folder, clone a fresh copy of gem5 from its 
[GitHub repository](https://github.com/gem5/gem5).

```shell
git clone https://github.com/gem5/gem5
cd gem5
```
### Building

Inside your personal gem5 directory, build gem5 with the following command.
```shell
scons build/X86/gem5.opt -j16 --linker=mold
```

gem5 uses [SCons](https://scons.org/) to build itself, which we access
using the `scons` command. 
-   The first argument (`build/X86/gem5.opt`) defines which version of gem5 to 
    build.
    - `X86` means we want to support the X86 ISA.
    - 'opt' means that optimizations are enabled, but basic debugging symbols
      are kept for easier debugging.
-   The second argument (`-j`) specifies the number of cores used to
    build parts of the binary in parallel.
-   The last argument (`--linker`) specifies which linker to use. The default
    linker, `ld`, is [quite slow](https://www.gem5.org/project/2023/02/16/benchmarking-linkers.html),
    so our environment provides a much faster linker called `mold`.

You may encounter some concerning messages or errors when trying to
build gem5:

-   The first time you build, you'll have to give approval to download a 
    pre-commit hooks file. Press Enter.
-   You may see a warning about not being able to find 'pre-commit'.
    Enter `y` as you don't need this.
-   You may see warnings about, deprecated namespaces, missing libraries, or
    other issues. These can be ignored as long the program compiles.
-   If you have any warnings or compilation errors, it's likely a problem with
    the Conda environment. Make sure you activated the environment by following
    the steps [here](../conda/README.md).

Grab a coffee, water, etc., as building will take a while!

### Usage
**TODO**

## ChampSim

Inside your personal folder, clone a fresh copy of ChampSim from its 
[GitHub repository](https://github.com/ChampSim/ChampSim).

```shell
git clone https://github.com/ChampSim/ChampSim
```

### Building

Before we can compile ChampSim, we need to set up the C++ packages it
requires. ChampSim uses the [vcpkg](<https://vcpkg.io/>) package manager to
manage its C++ dependencies. You can examine `vcpkg.json` to see what packages 
that ChampSim requires and to add your own as needed. 

Since the packages are very large (350+ MB), we have provided a `vcpkg` 
directory for you. Please run the following commands in the `ChampSim/` directory to link
to our `vcpkg` directory before continuing.

```shell
rm vcpkg -rf
ln -s /scratch/cluster/speedway/cs395t/champsim_vcpkg/vcpkg
ln -s /scratch/cluster/speedway/cs395t/champsim_vcpkg/vcpkg_installed
```

> [!WARNING] Do not follow the instructions under "Download dependencies" on the
> GitHub page, as we've already downloaded them for you!

Now, we can build ChampSim. Most of ChampSim's parameters are hard-coded at 
compile time, soyou'll need to rebuild for every configuration change. These parameters
are configured using a supplied JSON file. To change the current
configuration, you need to run:

```shell
./config.sh <JSON_FILE>
```

with the JSON configuration of your choice. To start, we can just use
the default configuration at `champsim_config.json`.

Now, let's build ChampSim! Run the following command:
```shell
make -j16
```

> [!NOTE]
> If you get a warning about clock skew, you can ignore this.

Once it's done building, you'll see a binary located at `bin/champsim`. One
annoying quirk about ChampSim is if you need to change the simulation 
parameters, you will need to recompile ChampSim. 

> [!TIP]
> If you're evaluating multiple configurations, you can keep a copy of each
> configuration's binary by creating a separate JSON file for each
> configuration and giving it a sensible `"executable_name"`.


### Usage

To run ChampSim, you need to provide a trace file and other command-line
arguments. Specifically:

```shell
bin/champsim --warmup-instructions <NUM_WARMUP_INSTRUCTIONS> \
    --simulation-instructions <NUM_SIMULATION_INSTRUCTIONS> \
    --json <STATS_FILE> \
    <TRACE_FILE>
```

ChampSim both prints out statistics to the terminal and also supports
dumping stats to a JSON file (using the `--json` flag).

> [!TIP]
> If you want to save the terminal output to a file, you can either
> redirect stdout to a file, or use `tee` to simultaneously redirect stdout
> while still seeing the output in the terminal.

If you want to understand the command line arguments more, just run:

```shell
./bin/champsim --help
```

# Part 2: Configuring Simulators

Now that you've gotten both simulators compiled, your next task will be to 
configure them such that they simulate a particular CPU. In particular, 
you'll be simulating a CPU loosely based on Intel Skylake (2015).

## Our "Skylake"-ish Specifications

Based loosely on publicly available documentation of the Intel Skylake
architecture (2015), both gem5 and ChampSim should be configured to have the
following specifications.

**CPU**:
> - CPU clock frequency: 4GHz
> - CPU reorder buffer (ROB) entries: 224
> - CPU load queue entries: 72
> - CPU store queue entries: 56


**L1 I-Cache**:
> - L1 I-Cache size: 32KB
> - L1 I-Cache associativity: 8
> - L1 I-Cache latency: 4
> - L1 I-Cache MSHRs: 8
> - L1 I-Cache replacement policy: LRU
> - L1 I-Cache prefetcher: None

**L1 D-Cache**:
> - L1 D-Cache size: 32KB
> - L1 D-Cache associativity: 8
> - L1 D-Cache latency: 4
> - L1 D-Cache MSHRs: 16
> - L1 D-Cache replacement policy: LRU
> - L1 D-Cache prefetcher: Stride Prefetcher, degree 3

**L2 Cache**:
> - L2 size: 1MB
> - L2 associativity: 16
> - L2 latency: 14
> - L2 MSHRs: 32
> - L2 replacement policy: LRU
> - L2 prefetcher: None

**LLC**:
> - LLC size: 8MB
> - LLC associativity: 16
> - LLC latency: 44
> - LLC MSHRs: 256
> - LLC replacement policy: LRU
> - LLC prefetcher: None

Note that you may have to do some math to figure out how many sets are
in each cache based on the size and associativity. Both simulators use a
cache line size of 64 bytes by default. Tag and data latency should be
set the same. ChampSim's stride prefetcher model is called `ip_stride`,
and it has a default degree of 3. You'll have to investigate the default
degree in the gem5 object.


## gem5

gem5 uses both Python and C++ in a unique way. Each simulated **object** is 
implemented in C++ but also has a Python wrapper. The Python wrapper provides
an **interface** for creating, configuring, using, and connecting objects,
called [stdlib](https://www.gem5.org/documentation/gem5-stdlib/overview) 
in gem5 lingo.

This is nice for many reasons! In particular, if you simply want to simulate two
different systems (e.g. a Skylake CPU vs. an Alder Lake CPU), you can write 
some Python configuration scripts which configure each system, without having to re-build 
gem5. Only when you change an object's C++ implementation, or create a new 
object (e.g., a new branch predictor proposal), will you need to re-build gem5.

Examine the configuration files under `gem5-configs-395t` until you understand 
the basic structure of the system we're creating. 

> [!NOTE]
> For all of the components, we extend a base class that's built into gem5. 
>
> In our config files, we create our own versions of various system components 
> (e.g. processor, caches, memory hierarchy) by inheriting the default settings 
> in the parent object and then overriding the ones we want to change. The 
> config files also demonstrate how you can do this configuration in object 
> constructors, allowing you to change some options easily from a top-level
> configuration file or the command line.
>
> In some cases, like Cache, some of the object's parameters don't have a default
> value. In these cases, you'll be required to provide a value yourself.

If you try running these file as-is, they won't work! That's because we left
some configuration options blank for you to fill in. If you grep through the 
config files for \"`FIXME`\", you'll find these blanks which you need to fill in.

Your job is to configure our CS395T system to look like the Intel Skylake using 
the specifications above. Mostly this will just be filling in numbers, but 
you'll have to instantiate and modify one component to modify the L1D prefetcher.

When you're finished filling in the missing information, try running a short 
simulation to make sure there are no errors (there may be some warnings from 
gem5).

```shell
GEM5_HOME=/path/to/gem5
$GEM5_HOME/build/X86/gem5.opt gem5-configs-395t/se_custom_binary.py \
    --input_bin $GEM5_HOME/tests/test-progs/hello/bin/x86/linux/hello
```

If that prints `Hello world!`, then your configuration is **valid**! To verify that
it is **correct**, look at `m5out/config.ini` and verify that the options listed 
there match the Skylake specifications.

## ChampSim

Start with the JSON configuration file at
`/scratch/cluster/speedway/cs395t/hw1a/champsim/start.json`. Copy it to
your personal ChampSim directory and edit it to match the provided Skylake 
parameters. You can also look at `champsim_config.json` to see the format of 
each options. Note that frequencies are in MHz.

Once you're done, build ChampSim with the new configuration.

# Part 3: Running Simulations

## Benchmarks

We have provided the following benchmarks to be used with gem5 and
ChampSim.

Commands and traces are located within `/scratch/cluster/speedway/cs395t/`.

| Name         | Description                                                 | Command (gem5)                                          | Trace (ChampSim)                  | Warmup instructions | Simulation instructions
| :----------- | :---------------------------------------------------------- | :------------------------------------------------------ | :-------------------------------- | ------------------: | -----------------------
| bfs_small    | Breadth-first search on a graph with 1M nodes and 15M edges | `./hw1a/gem5/bfs -n 1 -r 1 -f ./hw1a/gem5/bfs_small.sg` | `./hw1a/champsim/bfs_small.xz`    | 0                   | 102,792,572
| bfs_med      | Breadth-first search on a graph with 4M nodes and 64M edges | `./hw1a/gem5/bfs -n 1 -r 1 -f ./hw1a/gem5/bfs_med.sg`   | `./hw1a/champsim/bfs_med.xz`      | 0                   | 281,370,362
| matmul_small | 1290 $\times$ 1290 matrix multiply, unoptimized             | `./hw1a/gem5/matmul_small`                              | `./hw1a/champsim/matmul_small.xz` | 0                   | 100,010,899
| matmul_med   | 2041 $\times$ 2041 matrix multiply, unoptimized             | `./hw1a/gem5/matmul_med`                                | `./hw1a/champsim/matmul_med.xz`   | 0                   | 250,116,227


## gem5

Next, you will your first real program: breadth-first search on a
1-million-node graph. This will take 10-15 minutes. (Note that this
program executes only about 100 million instructions, whereas SPEC
programs execute many billions!). Here's the run command in general:

```shell
$GEM5_HOME/build/X86/gem5.opt \
    --outdir=path/to/outdir/ \
    -- gem5-configs-395t/se_custom_binary.py \
    --input_bin <CMD> --input_args <ARGS>
```

The first line invokes the gem5 binary. If you leave off `--outdir`, all
output will go in the default directory, `m5out`, and will be
overwritten on subsequent runs. By default only statistics go in that
directory; if you want to redirect standard error and standard out to
files as well, add the flags `-re` after the outdir. (Doing so will make
your simulations run slightly faster.)

The second line specifies a top-level Python script which contains the
configuration that instantiates your system components and manages the
simulation. Note that this is a file we provided and you edited; it's
not built into gem5. You're always responsible for setting up the system
and simulation we want to run. The repository also contains several
scripts for running SE or FS simulations for different benchmark suites
and use cases---some of which we'll explore later on in this course.

The third line specifies whatever arguments your top-level Python script
requires. Since you provide this file yourself, you could make it take
whatever CLI arguments you want, e.g., configuring the prefetcher, and
in fact this script lets you do so. For this assignment, we will use the
following arguments:

-   `--input_bin` specifies the binary whose execution you want to
    simulate\
    (e.g. `--input_bin /path/to/bin`)
-   `--input_args` specifies the binary's arguments. If you have more
    than one argument, you must wrap the entire argument list in double
    quotes (e.g. `--input_args "-arg1 a -arg2 b"`).

You can learn about the other arguments by providing the `--help` flag to
the script.

To start, we want you to run the `bfs_small` benchmark; you can find the
run command in the Benchmarks section below. Use that exact run command,
including exact order of arguments.

gem5 writes its output to the `stats.txt` inside of `m5out` or your
specified output directory via `--outdir`. Look through stats.txt to see
what's there. Can you calculate the average instructions per cycle? What
about cache hit and miss ratios, or the miss rate (misses per thousand
instructions, MPKI) in each level of the data cache?

### Results

Once you get `bfs_small` working on the default configuration, configure
the CPU and caches to match Skylake's parameters by passing values to
the script's arguments, and run all the benchmarks. To make sure your
configuration matches ours, we stored reference gem5 stats files at:

-   `/scratch/cluster/speedway/cs395t/hw1a/gem5/bfs_small_stats`
-   `/scratch/cluster/speedway/cs395t/hw1a/gem5/matmul_small_stats`

for `bfs_small` and `matmul_small` respectively. You can diff your
stats.txt files against these. They will not diff completely clean, but
the only differences should be lines that start with `host`, which
refers to the real system on which you ran gem5, not the simulated
system.

The stats.txt files are very large. Here are some particular statistics
you may find interesting:

```
core.thread_0.numInsts      # number of instructions committed
core.thread_0.numOps        # number of micro-ops committed
core.numCycles              # number of CPU cycles
commit.branchMispredicts    # number of committed branch mispredicts
iew.branchMispredicts       # number of executed branch mispredicts
l1dcaches.overallMisses::total
l1dcaches.overallAccesses::total
l2caches.overallMisses::cache_hierarchy.l1dcaches.prefetcher
l2caches.overallMisses::processor.cores.core.data
l2caches.overallMisses::total
l2caches.overallAccesses::cache_hierarchy.l1dcaches.prefetcher
l2caches.overallAccesses::processor.cores.core.data
l2caches.overallAccesses::total
llcache.overallMisses::cache_hierarchy.l1dcaches.prefetcher
llcache.overallMisses::processor.cores.core.data
llcache.overallMisses::total
llcache.overallAccesses::cache_hierarchy.l1dcaches.prefetcher
llcache.overallAccesses::processor.cores.core.data
llcache.overallAccesses::total
```

## ChampSim

We've generated trace files for the same programs we simulated with
gem5, which you can find under "Trace:" in the Benchmarks section below.
(If you wanted to generate traces on your own, you could do so with the
Pin tool in `ChampSim/tracer/pin/`. In this class, we'll always give you
traces.) For now, we'll run the entire trace, so set `NUM_WARMUP` to 0
and `NUM_SIMULATION` to the total number of instructions in the binary,
listed below.\

### Results

To make sure your configuration matches ours, we stored the ChampSim
output files at:

-   `/scratch/cluster/speedway/cs395t/hw1a/champsim/bfs_small_stats`
-   `/scratch/cluster/speedway/cs395t/hw1a/champsim/matmul_small_stats`

for `bfs_small` and `matmul_small` respectively. Note that the only
lines that need to match exactly are those following the line
`=== Simulation ===`. We also provide the JSON output for these as well.

# Part 4: Experiment

Finally, you should perform a small experiment with both simulators and 
report the results. This experiment can be anything you want! 
(Research is usually very open-ended.) The only rules are that:

1. You must change something about the simulator configurations.
2. You must conclude something from your results.

Ideally, you'll change something meaningful enough that impacts performance 
in some observable way. For example, you could experiment with a range of cache
sizes, different prefetchers, etc.

If your experiment results in only a small impact on performance and/or
other statistics, that's OK. However, please try to explain why you think
this happened and what you've concluded.

Please conduct your experiments on the two medium-size benchmarks 
(`bfs-med`, `matmul-med`).

> [!NOTE]
> These benchmarks can take 30-45 minutes to simulate in gem5, so please leave 
> yourself enough time to gather your results! 
> 
> You're welcome to run multiple simulations in parallel, but please be mindful
> of other students and don't take up all the cores on the machines.

## Report

You should write a brief report that contains the following:

-   A **description** of the experiment you conducted.
-   The **results** you got from your experiment.
-   Your **conclusions** from the results.
-   Your **answers** to the following two questions:
    1.  Why do the statistics from gem5 and ChampSim for the same test
        application differ? How far off are they? Speculate why, using what you 
        know about each simulator and what you observed in the configuration
        files for each.
    2.  What other experiments would you run if you had more time and if you 
        could change *anything* in the simulator that you wanted to, not
        just what we've shown you how to do here? Describe at least two
        more experiments you might run, and what you would hope to learn
        from them.

## Submission

In a `.zip` file, submit the following:

1.  Your modified **gem5 configuration files**, *i.e.* those containing \"FIXME\"
    and anything else you changed for your experiemnts.
2.  The `config.ini` file from one of your gem5 simulations, located in
    your simulation's output directory. It should match our Skylake
    specification.
-   The `.json` ChampSim configuration file you used. It should also
    match our Skylake specification.
-   Your report, as a `.pdf` file.

Upload the `.zip` file to Canvas under "Assignment 1a",
and leave a comment with the names of everyone in your group.

## Grading

Your assignment will be graded on several aspects:
-   **Implementation:** Your submission produces statistics output that
    matches ours, i.e., you configured both simulators correctly.
-   **Experiment:** You investigated the impact of some relevant
    configuration change with empirical results, your experiment is well
    described, and your analysis is concise and logically displayed.
-   **Discussion:** Your report shares your rationale for conducting the
    experiment you did and includes your conclusions. It also theorizes
    on the differences in results between the two simulators and
    describes two additional experiments you might like to run.

